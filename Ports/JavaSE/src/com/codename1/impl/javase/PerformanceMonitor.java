/*
 * Copyright (c) 2012, Codename One and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Codename One designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *  
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Please contact Codename One through http://www.codenameone.com/ if you 
 * need additional information or have any questions.
 */
package com.codename1.impl.javase;

import com.codename1.ui.Component;
import com.codename1.ui.Display;
import com.codename1.ui.Image;
import com.codename1.ui.Label;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;

/**
 * The Codename One performance monitor shows you how long (in nano-seconds) it took to paint a specific
 *
 * @author Shai Almog
 */
public class PerformanceMonitor extends javax.swing.JFrame {
    private int componentId = 0;
    private static String idString = "$prefid";
    private Map<Integer, Stats> componentStats = new HashMap<Integer, Stats>();
    
    private boolean paused;
    private static final String[] COLUMNS = {
        "Name", "Type", "UIID", "Parent Name", "Icon", "Invocations", "Fastest", "Slowest", "Average"        
    };
    private static final Class[] COLUMN_CLASSES = {
        String.class, String.class, String.class, String.class, String.class, Integer.class, Long.class, Long.class, Long.class
    };

    private int imageRam;
    
    /** Creates new form PerformanceMonitor */
    public PerformanceMonitor() {
        initComponents();
        resultData.setModel(new Model());
        performanceLog.setLineWrap(true);
        resultData.setRowSorter(new TableRowSorter<Model>((Model)resultData.getModel()));
    }
    
    public void addImageRAM(int ram) {
        imageRam += ram;
        imageMemory.setText("Image Memory Overhead: " + imageRam);
    }

    public void removeImageRAM(int ram) {
        imageRam -= ram;
        imageMemory.setText("Image Memory Overhead: " + imageRam);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane2 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jScrollPane1 = new javax.swing.JScrollPane();
        resultData = new javax.swing.JTable();
        clearData = new javax.swing.JButton();
        pauseContinue = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        performanceLog = new javax.swing.JTextArea();
        imageMemory = new javax.swing.JLabel();
        runGC = new javax.swing.JButton();

        FormListener formListener = new FormListener();

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane2.setViewportView(jTable1);

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Performance Monitor");
        addWindowListener(formListener);

        jScrollPane1.setViewportView(resultData);

        clearData.setText("Clear Data");
        clearData.addActionListener(formListener);

        pauseContinue.setText("Pause/Continue");
        pauseContinue.addActionListener(formListener);

        jLabel1.setText("Component Details (times are in nano-seconds: one billionth of a second)");

        jLabel2.setText("Log");

        performanceLog.setColumns(20);
        performanceLog.setRows(5);
        jScrollPane3.setViewportView(performanceLog);

        imageMemory.setText("Image Memory Overhead: (Calculating...)");

        runGC.setText("GC");
        runGC.addActionListener(formListener);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 817, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 817, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(clearData)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(pauseContinue)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 122, Short.MAX_VALUE)
                        .addComponent(runGC)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(imageMemory))
                    .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.LEADING))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {clearData, pauseContinue, runGC});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(clearData)
                    .addComponent(pauseContinue)
                    .addComponent(imageMemory)
                    .addComponent(runGC))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 199, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }

    // Code for dispatching events from components to event handlers.

    private class FormListener implements java.awt.event.ActionListener, java.awt.event.WindowListener {
        FormListener() {}
        public void actionPerformed(java.awt.event.ActionEvent evt) {
            if (evt.getSource() == clearData) {
                PerformanceMonitor.this.clearDataActionPerformed(evt);
            }
            else if (evt.getSource() == pauseContinue) {
                PerformanceMonitor.this.pauseContinueActionPerformed(evt);
            }
            else if (evt.getSource() == runGC) {
                PerformanceMonitor.this.runGCActionPerformed(evt);
            }
        }

        public void windowActivated(java.awt.event.WindowEvent evt) {
        }

        public void windowClosed(java.awt.event.WindowEvent evt) {
        }

        public void windowClosing(java.awt.event.WindowEvent evt) {
            if (evt.getSource() == PerformanceMonitor.this) {
                PerformanceMonitor.this.formWindowClosing(evt);
            }
        }

        public void windowDeactivated(java.awt.event.WindowEvent evt) {
        }

        public void windowDeiconified(java.awt.event.WindowEvent evt) {
        }

        public void windowIconified(java.awt.event.WindowEvent evt) {
        }

        public void windowOpened(java.awt.event.WindowEvent evt) {
        }
    }// </editor-fold>//GEN-END:initComponents

    public void printToLog(String t) {
        performanceLog.append(t + "\n");
    }   
    
    private void pauseContinueActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pauseContinueActionPerformed
        paused = !paused;
    }//GEN-LAST:event_pauseContinueActionPerformed

    private void clearDataActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearDataActionPerformed
        ((Model)resultData.getModel()).clear();
    }//GEN-LAST:event_clearDataActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        JavaSEPort.disablePerformanceMonitor();
    }//GEN-LAST:event_formWindowClosing

    private void runGCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runGCActionPerformed
        System.gc(); System.gc();
    }//GEN-LAST:event_runGCActionPerformed

    public void beforeComponentPaint(Component c) {
        if(!paused) {
            c.putClientProperty("$t", new Long(System.nanoTime()));
        }
    }

    public void afterComponentPaint(Component c) {
        if(paused) {
            return;
        }
        long t = System.nanoTime();
        Long l = (Long)c.getClientProperty("$t");
        if(l != null) {
            t = t - l.longValue();
            Integer id = (Integer)c.getClientProperty(idString);
            Stats st;
            if(id == null) {
                id = new Integer(componentId);
                c.putClientProperty(idString, id);
                componentId++;
                st = new Stats(c);
                componentStats.put(id, st);                    
            } else {
                st = componentStats.get(id);
                if(st == null) {
                    st = new Stats(c);
                    componentStats.put(id, st); 
                }
            }
            st.updateInvocation(t);
        }
    }
    
    static class Stats {
        private String name;
        private String type;
        private String uiid;
        private String parentName;
        private String imageName;
        private int invocationCount;
        private long fastest = Long.MAX_VALUE;
        private long slowest;
        private long[] allInvocations = new long[20];

        public Stats(Component c) {
            name = c.getName();
            type = c.getClass().getName();
            uiid = c.getUIID();
            if(c instanceof Label) {
                Image l = ((Label)c).getIcon();
                if(l != null) {
                    imageName = l.getImageName();
                }
            }
            if(c.getParent() != null) {
                parentName = c.getParent().getName();
            } 
        }
        
        public void updateInvocation(long t) {
            fastest = Math.min(t, fastest);
            slowest = Math.max(t, slowest);
            if(allInvocations.length <= invocationCount) {
                long[] arr = new long[allInvocations.length * 3];
                System.arraycopy(allInvocations, 0, arr, 0, allInvocations.length);
                allInvocations = arr;
            }
            allInvocations[invocationCount] = t;
            invocationCount++;
        }
        
        public long getAverage() {
            long total = 0;
            for(int iter = 0 ; iter < invocationCount ; iter++) {
                total += allInvocations[iter];
            }
            return total / invocationCount;
        }
        
        /**
         * @return the name
         */
        public String getName() {
            return name;
        }

        /**
         * @return the type
         */
        public String getType() {
            return type;
        }

        /**
         * @return the parentName
         */
        public String getParentName() {
            return parentName;
        }

        /**
         * @return the invocationCount
         */
        public int getInvocationCount() {
            return invocationCount;
        }

        /**
         * @return the fastest
         */
        public long getFastest() {
            return fastest;
        }

        /**
         * @return the slowest
         */
        public long getSlowest() {
            return slowest;
        }

        /**
         * @return the allInvocations
         */
        public long[] getAllInvocations() {
            return allInvocations;
        }

        /**
         * @return the uiid
         */
        public String getUiid() {
            return uiid;
        }

        /**
         * @return the imageName
         */
        public String getImageName() {
            return imageName;
        }
        
    }
    
    class Model implements TableModel {
        private List<TableModelListener> listeners = new ArrayList<TableModelListener>();

        @Override
        public int getRowCount() {
            return componentStats.size();
        }

        @Override
        public int getColumnCount() {
            return COLUMNS.length;
        }

        @Override
        public String getColumnName(int i) {
            return COLUMNS[i];
        }

        @Override
        public Class<?> getColumnClass(int i) {
            return COLUMN_CLASSES[i];
        }

        @Override
        public boolean isCellEditable(int i, int i1) {
            return false;
        }

        @Override
        public Object getValueAt(int row, int column) {
            Stats s = componentStats.get(row);
            switch(column) {
                case 0:
                    return s.getName();
                case 1:
                    return s.getType();
                case 2:
                    return s.getUiid();
                case 3:
                    return s.getParentName();
                case 4:
                    return s.getImageName();
                case 5:
                    return s.getInvocationCount();
                case 6:
                    return s.getFastest();
                case 7:
                    return s.getSlowest();
                default:
                    return s.getAverage();
            }
        }
        
        public void clear() {
            componentStats.clear();            
            componentId = 0;
            idString += "x";
            fireUpdate();
        }

        @Override
        public void setValueAt(Object o, int i, int i1) {
        }

        void fireUpdate() {
            for(TableModelListener t : listeners) {
                t.tableChanged(new TableModelEvent(this));
            }
        }

        private boolean first;
        @Override
        public void addTableModelListener(TableModelListener tl) {
            listeners.add(tl);
            if(!first) {
                first = true;
                javax.swing.Timer t = new javax.swing.Timer(2000, new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent ae) {
                        if(!paused) {
                            fireUpdate();
                        }
                    }
                });
                t.setRepeats(true);
                t.start();
            }
        }

        @Override
        public void removeTableModelListener(TableModelListener tl) {
            listeners.remove(tl);
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton clearData;
    private javax.swing.JLabel imageMemory;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTable jTable1;
    private javax.swing.JButton pauseContinue;
    private javax.swing.JTextArea performanceLog;
    private javax.swing.JTable resultData;
    private javax.swing.JButton runGC;
    // End of variables declaration//GEN-END:variables
}
